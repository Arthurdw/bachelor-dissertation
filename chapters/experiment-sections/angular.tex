% + no VDOM overhead
% + lots of built in/standard dependencies
% + client side, but has SSR baked in
% + big ecosystem
% + dependency injection
% + great documentation
% + standard typescript and html files (custom templating language in the html)
% + scope of css is easily determinable
% + backed by Google
% + lots of usage (especially in enterprises)
% + CLI application to generate the basic boilerplate
% + stable updating process
% + build in routing framework is stable and powerful
% + instead of components css selectors are used, this gives you much more power to create advanced component behavior
% - state management is complex (eg, to ways of managing state, with and without signals; but signals can only expect signals as argument)
% - templating language is less powerful compared to the other solutions (eg argument passing to slots)
% - complex syntax
% - i18n can not change in development mode (a separate build is required for each language)
% - uses different terminologies than all other frameworks
% - lots of boilerplate (mostly for legacy purposes)
% - doesn't always use the type systems (eg for an @input you have to explicitly set required: true, instead of deriving this form the typescript type)



\section{Angular}
\label{sec:angular}

\subsection{Overview}
\label{subsec:angular:overview}
\itodo{write this}

\subsection{Strengths}
\label{subsec:angular:strengths}
\begin{itemize}
    \item strength! \todo{write strengths}
\end{itemize}

\subsection{Weaknesses}
\label{subsec:angular:weaknesses}
\begin{itemize}
    \item weakness! :( \todo{write weaknesses}
\end{itemize}